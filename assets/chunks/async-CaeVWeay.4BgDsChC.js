import{a2 as d,K as g,l as P,M as x,a3 as T,a4 as m,a5 as R,j as h,v as J,J as w}from"./eo-dash.BCjMEFJP.js";import{i as E}from"./utils.DZj92Qv1.js";import{p as k}from"./framework.D4jZKuzb.js";function B(e){return Object.keys((e==null?void 0:e.properties)??{}).find(s=>(e==null?void 0:e.properties[s].format)==="bounding-box")}function U(e){return Object.keys((e==null?void 0:e.properties)??{}).filter(s=>(e==null?void 0:e.properties[s].type)==="geojson")}function K(e,s){const t=U(s);for(const r of t)e[r]&&(E(s==null?void 0:s.properties[r])?e[r]=e[r].features.map(o=>JSON.stringify(o.geometry)):e[r]=JSON.stringify(e[r].geometry))}async function W(e,s,t,r,o){let a=null;"eox:flatstyle"in(e??{})&&(a=await w.get(e["eox:flatstyle"]).then(i=>i.data));let l,n;if(a){const i=x(s??"",a);l=i.layerConfig,n=i.style}t=t.sort();const u=t.length>0?{type:"WebGLTile",source:{type:"GeoTIFF",normalize:!n,sources:t.map(i=>({url:i}))},properties:{id:e.id+"_process"+o,title:"Results "+s,...l&&{layerConfig:l},layerControlToolsExpand:!0},...n&&{style:n}}:void 0;return r&&u&&(u.source.projection=r),u}const $=(e,s)=>{if(!s)return;let t=s;if(typeof s=="object"){s=JSON.stringify(s);const o=new Blob([s],{type:"text"});t=URL.createObjectURL(o)}const r=document.createElement("a");confirm(`Would you like to download ${e}?`)&&(r.href=t,r.download=e,r.click()),URL.revokeObjectURL(t),r.remove()};function z(e,s,t){let r="",o="";[r,o]=s??["",""];const[a,l]=e??["",""];try{if(r&&o?(r=new Date(r),o=new Date(o)):(r=new Date(a),o=new Date(l)),(r<new Date(a)||r>new Date(l))&&(console.warn("[eodash] warn: start date is outside of the collection temporal extent and will be clamped",`
provided start date:${r.toISOString()}`,`
collection start date:${a}`),r=new Date(a)),(o>new Date(l)||o<new Date(a))&&(console.warn("[eodash] warn: end date is outside of the collection temporal extent and will be clamped",`
provided end date:${o.toISOString()}`,`
collection end date:${l}`),o=new Date(l)),r>o)return console.error("[eodash] Error: start date is greater than end date",r,o),[]}catch(f){return console.error("[eodash] Invalid date:",f.message),[]}const n=r.toISOString(),u=o.toISOString();if(!n||!u)return[];const i=[];let c=new Date(u);const p=new Date(n),y=24*60*60*1e3,O=t==="daily"?y:t==="weekly"?y*7:t==="monthly"?y*30:t==="yearly"?y*365:y;for(;c>=p&&i.length<31;)i.push(new Date(c)),c.setTime(c.getTime()-O);const b=[];for(let f=0;f<i.length-1;f++)b.push([i[f].toISOString(),i[f+1].toISOString()]);return b}function q(e,s,t){if(!e)return[[],[]];const r=[],o=[];for(const a of e){const l=a.rel===s,n=t?a.type===t:!0;l&&n&&(a.endpoint?o.push(a):r.push(a))}return[r,o]}async function _(e,s,t,r=""){var l;const o=[],a=await G(s);for(const n of e){const u=N(n,a);let i,c;if(u){const p=x((t==null?void 0:t.id)??"",u);c=p.layerConfig,i=p.style}switch(n.type){case"image/tiff":{o.push({type:"WebGLTile",properties:{id:s.id+"_process"+n.id+r,title:"Results "+((t==null?void 0:t.id)??"")+" "+(n.id??""),layerControlToolsExpand:!0,...c&&{layerConfig:c}},source:{type:"GeoTIFF",normalize:!i,sources:n.urls.map(p=>({url:p})),...((l=t["eodash:mapProjection"])==null?void 0:l.name)&&{projection:t["eodash:mapProjection"].name}},...i&&{style:i}});break}case"application/geo+json":{const p=await T(n.urls);o.push({type:"Vector",source:{type:"Vector",format:"GeoJSON",...p&&{url:p}},properties:{id:s.id+"_process_"+n.id+r,title:"Results "+((t==null?void 0:t.id)??"")+" "+(n.id??""),...c&&{layerConfig:{...c,style:i}}},...!(i!=null&&i.variables)&&{style:i},interactions:[]});break}default:console.warn(`[eodash] Unsupported result type "${n.type}" for ${n.id} layer creation.`);break}}return o}async function G(e){let s=null;return e["eox:flatstyle"]&&(typeof e["eox:flatstyle"]=="string"?s=await w.get(e["eox:flatstyle"]).then(t=>t.data):Array.isArray(e["eox:flatstyle"])&&e["eox:flatstyle"].length?(s={multipleStyles:!0},await Promise.all(e["eox:flatstyle"].map(async t=>{s[t.id]=await w.get(t.url).then(r=>r.data)}))):(s={multipleStyles:!0},await Promise.all(Object.keys(e["eox:flatstyle"]??{}).map(t=>{s[t]=w.get(e["eox:flatstyle"][t]).then(r=>r.data)})))),s}function N(e,s){if(!s)return;if(!("multipleStyles"in s))return s;const t=e.id;if(!(!t||!(t in s)))return s[t]}function C(e){if(!e)return[];if("urls"in e&&Array.isArray(e.urls))return[{id:"",urls:e.urls,type:"image/tiff"}];const s=[];for(const t in e)t!=="id"&&s.push({id:t,urls:e[t].urls,type:e[t].mimetype});return s}const L=e=>{var s;if(e.length){const t=[...m()];let r=t.find(o=>{var a;return(a=o.properties)==null?void 0:a.id.includes("AnalysisGroup")});if(!r)return;for(const o of e)r.layers.find(l=>{var n,u;return((n=l.properties)==null?void 0:n.id)===((u=o.properties)==null?void 0:u.id)})?r.layers=R(r.layers,((s=o.properties)==null?void 0:s.id)??"",[o]):r.layers.unshift(o);if(h.value){const o=[...t];J("process:updated",h.value,o),h.value.layers=o}}},D=k([]);async function H({processUrl:e,isPolling:s,pollInterval:t=1e4,maxRetries:r=560}){let o=0;for(s.value=!0,setTimeout(()=>{v(D,g.value)},500);o<r&&s.value;){try{const a=new Date().getTime(),n=(await d.get(`${e}?t=${a}`)).data;if(n.status==="successful"){console.log("Process completed successfully. Fetching result item...");const u=n.links[1].href;if(!u)throw new Error("Result links not found in the process report.");const i=await d.get(u);return console.log("Result file fetched successfully:",i.data),i.data}if(n.status==="failed")throw s.value=!1,new Error("Process failed.",n);console.log(`Status: ${n.status}. Retrying in ${t/1e3} seconds...`)}catch(a){a instanceof Error?console.error("Error while polling process status:",a.message):console.error("Unknown error occurred:",a)}await new Promise(a=>setTimeout(a,t)),o++}if(!s.value)return console.warn("Polling was stopped before the process was completed."),JSON.parse("{}");throw new Error("Max retries reached. Process did not complete successfully.")}async function v(e,s){const t=JSON.parse(localStorage.getItem(s)||"[]"),r=await Promise.all(t.map(o=>d.get(o,{params:{t:Date.now()}}).then(a=>a.data)));r.sort((o,a)=>new Date(a.job_start_datetime).getTime()-new Date(o.job_start_datetime).getTime()),e.value=r}const Q=async e=>{const t=JSON.parse(localStorage.getItem(g.value)||"[]").filter(r=>!r.includes(e.jobID));localStorage.setItem(g.value,JSON.stringify(t)),await v(D,g.value)},X=async(e,s)=>{const t=[],r=e.links.find(o=>o.rel.includes("results")&&o.type=="application/json");r&&(await d.get(r.href).then(o=>o.data).then(o=>{t.push(...o.urls)}),t.forEach(o=>{if(!o)return;let a="";typeof o=="string"?(a=o.includes("/")?o.split("/").pop()??"":o,a=a.includes("?")?a.split("?")[0]:a):a=(s==null?void 0:s.id)+"_process_results.json",$(a,o)}))},Y=async(e,s)=>{const t=await d.get(e.links[1].href).then(r=>r.data);await A({selectedStac:s,results:t,jobId:e.jobID})};async function A({selectedStac:e,results:s,jobId:t}){const r=e==null?void 0:e.links.find(l=>l.rel==="service"&&l.endpoint=="eoxhub_workspaces");if(!r)return;const o=C(s),a=await _(o,r,e,t);P.debug("rendered layers after loading previous process:",a),L(a)}export{L as a,C as b,W as c,_ as d,K as e,z as f,B as g,X as h,Q as i,D as j,$ as k,Y as l,H as p,q as s,v as u};
