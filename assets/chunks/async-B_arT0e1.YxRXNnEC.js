import{al as y,$ as f,l as O,a2 as x,j as w,a0 as T,a4 as k}from"./eo-dash.C6HHCnkX.js";import{g as P}from"./utils.C66ckBg2.js";import{p as I}from"./framework.BfoLFm0x.js";function _(t){return Object.keys((t==null?void 0:t.properties)??{}).find(r=>(t==null?void 0:t.properties[r].format)==="bounding-box")}function J(t){return Object.keys((t==null?void 0:t.properties)??{}).filter(r=>(t==null?void 0:t.properties[r].type)==="geojson")}function C(t,r){const o=J(r);for(const e of o)t[e]&&(P(r==null?void 0:r.properties[e])?t[e]=t[e].features.map(s=>JSON.stringify(s.geometry)):t[e]=JSON.stringify(t[e].geometry))}async function L(t,r,o,e,s){let n=null;"eox:flatstyle"in(t??{})&&(n=await T.get(t["eox:flatstyle"]).then(l=>l.data));let i,a;if(n){const l=k(r??"",n);i=l.layerConfig,a=l.style}o=o.sort();const c=o.length>0?{type:"WebGLTile",source:{type:"GeoTIFF",normalize:!a,sources:o.map(l=>({url:l}))},properties:{id:t.id+"_process"+s,title:"Results "+r,...i&&{layerConfig:i},layerControlToolsExpand:!0},...a&&{style:a}}:void 0;return e&&c&&(c.source.projection=e),c}const R=(t,r)=>{if(!r)return;let o=r;if(typeof r=="object"){r=JSON.stringify(r);const s=new Blob([r],{type:"text"});o=URL.createObjectURL(s)}const e=document.createElement("a");confirm(`Would you like to download ${t}?`)&&(e.href=o,e.download=t,e.click()),URL.revokeObjectURL(o),e.remove()};function F(t,r,o){let e="",s="";[e,s]=r??["",""];const[n,i]=t??["",""];try{if(e&&s?(e=new Date(e),s=new Date(s)):(e=new Date(n),s=new Date(i)),(e<new Date(n)||e>new Date(i))&&(console.warn("[eodash] warn: start date is outside of the collection temporal extent and will be clamped",`
provided start date:${e.toISOString()}`,`
collection start date:${n}`),e=new Date(n)),(s>new Date(i)||s<new Date(n))&&(console.warn("[eodash] warn: end date is outside of the collection temporal extent and will be clamped",`
provided end date:${s.toISOString()}`,`
collection end date:${i}`),s=new Date(i)),e>s)return console.error("[eodash] Error: start date is greater than end date",e,s),[]}catch(p){return console.error("[eodash] Invalid date:",p.message),[]}const a=e.toISOString(),c=s.toISOString();if(!a||!c)return[];const l=[];let u=new Date(c);const D=new Date(a),d=24*60*60*1e3,v=o==="daily"?d:o==="weekly"?d*7:o==="monthly"?d*30:o==="yearly"?d*365:d;for(;u>=D&&l.length<31;)l.push(new Date(u)),u.setTime(u.getTime()-v);const g=[];for(let p=0;p<l.length-1;p++)g.push([l[p].toISOString(),l[p+1].toISOString()]);return g}function G(t,r,o){if(!t)return[[],[]];const e=[],s=[];for(const n of t){const i=n.rel===r,a=o?n.type===o:!0;i&&a&&(n.endpoint?s.push(n):e.push(n))}return[e,s]}const b=I([]);async function M({processUrl:t,isPolling:r,pollInterval:o=1e4,maxRetries:e=560}){let s=0;for(r.value=!0,setTimeout(()=>{h(b,f)},500);s<e&&r.value;){try{const n=new Date().getTime(),a=(await y.get(`${t}?t=${n}`)).data;if(a.status==="successful"){console.log("Process completed successfully. Fetching result item...");const c=a.links[1].href;if(!c)throw new Error("Result links not found in the process report.");const l=await y.get(c);return console.log("Result file fetched successfully:",l.data),l.data}if(a.status==="failed")throw r.value=!1,new Error("Process failed.",a);console.log(`Status: ${a.status}. Retrying in ${o/1e3} seconds...`)}catch(n){n instanceof Error?console.error("Error while polling process status:",n.message):console.error("Unknown error occurred:",n)}await new Promise(n=>setTimeout(n,o)),s++}if(!r.value)return console.warn("Polling was stopped before the process was completed."),JSON.parse("{}");throw new Error("Max retries reached. Process did not complete successfully.")}async function h(t,r){const o=JSON.parse(localStorage.getItem(r.value)||"[]"),e=await Promise.all(o.map(s=>fetch(s).then(n=>n.json())));e.sort((s,n)=>new Date(n.job_start_datetime).getTime()-new Date(s.job_start_datetime).getTime()),t.value=e}const B=async t=>{const o=JSON.parse(localStorage.getItem(f.value)||"[]").filter(e=>!e.includes(t.jobID));localStorage.setItem(f.value,JSON.stringify(o)),h(b,f)},m=async(t,r)=>{const o=[];await fetch(t.links[1].href).then(e=>e.json()).then(e=>{o.push(...e.urls)}),o.forEach(e=>{if(!e)return;let s="";typeof e=="string"?(s=e.includes("/")?e.split("/").pop()??"":e,s=s.includes("?")?s.split("?")[0]:s):s=(r==null?void 0:r.id)+"_process_results.json",R(s,e)})},W=async(t,r)=>{const o=[];await y.get(t.links[1].href).then(e=>o.push(e.data)),await E({selectedStac:r,results:o,jobId:t.jobID})};async function E({selectedStac:t,results:r,jobId:o}){var n;const e=t==null?void 0:t.links.filter(i=>i.rel==="service"&&i.type==="image/tiff"),s=await L(e==null?void 0:e[0],(t==null?void 0:t.id)??"",r==null?void 0:r[0].urls,((n=t==null?void 0:t["eodash:mapProjection"])==null?void 0:n.name)??null,o);if(O.debug("rendered layers after loading previous process:",s),s){const i=[...s?[s]:[]];let a=[...x()],c=a.find(l=>{var u;return(u=l.properties)==null?void 0:u.id.includes("AnalysisGroup")});c==null||c.layers.push(...i),w.value&&(w.value.layers=[...a])}}export{F as a,m as b,L as c,R as d,C as e,B as f,_ as g,b as j,W as l,M as p,G as s,h as u};
