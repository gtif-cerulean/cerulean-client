import{Z as m}from"./lit-element.Deg-YTNa.js";function l(e,r,t={}){const n={type:"Feature"};return(t.id===0||t.id)&&(n.id=t.id),t.bbox&&(n.bbox=t.bbox),n.properties=r||{},n.geometry=e,n}function _(e,r,t={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");if(e.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!g(e[0])||!g(e[1]))throw new Error("coordinates must contain numbers");return l({type:"Point",coordinates:e},r,t)}function $(e,r,t={}){for(const i of e){if(i.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(i[i.length-1].length!==i[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<i[i.length-1].length;o++)if(i[i.length-1][o]!==i[0][o])throw new Error("First and last Position are not equivalent.")}return l({type:"Polygon",coordinates:e},r,t)}function y(e,r,t={}){if(e.length<2)throw new Error("coordinates must be an array of two or more positions");return l({type:"LineString",coordinates:e},r,t)}function d(e,r={}){const t={type:"FeatureCollection"};return r.id&&(t.id=r.id),r.bbox&&(t.bbox=r.bbox),t.features=e,t}function x(e,r,t={}){return l({type:"MultiLineString",coordinates:e},r,t)}function g(e){return!isNaN(e)&&e!==null&&!Array.isArray(e)}/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{I:b}=m,p=e=>e.strings===void 0,c=()=>document.createComment(""),v=(e,r,t)=>{var o;const n=e._$AA.parentNode,i=r===void 0?e._$AB:r._$AA;if(t===void 0){const a=n.insertBefore(c(),i),f=n.insertBefore(c(),i);t=new b(a,f,e,e.options)}else{const a=t._$AB.nextSibling,f=t._$AM,u=f!==e;if(u){let s;(o=t._$AQ)==null||o.call(t,e),t._$AM=e,t._$AP!==void 0&&(s=e._$AU)!==f._$AU&&t._$AP(s)}if(a!==i||u){let s=t._$AA;for(;s!==a;){const A=s.nextSibling;n.insertBefore(s,i),s=A}}}return t},E=(e,r,t=e)=>(e._$AI(r,t),e),h={},P=(e,r=h)=>e._$AH=r,S=e=>e._$AH,B=e=>{var n;(n=e._$AP)==null||n.call(e,!1,!0);let r=e._$AA;const t=e._$AB.nextSibling;for(;r!==t;){const i=r.nextSibling;r.remove(),r=i}};export{B as M,l as a,d as b,_ as c,x as d,S as e,p as f,y as l,P as m,$ as p,v as r,E as v};
